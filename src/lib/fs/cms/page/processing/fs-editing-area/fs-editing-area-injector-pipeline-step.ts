import { PipelineStep } from '../pipeline-step';
import { BaseSiteService, CmsStructureModel, ContentSlotData } from '@spartacus/core';
import { getSlotIgnoreCase } from '../../../../util/content-slots';
import { Injectable } from '@angular/core';
import { FsCmsPageComponentInjector } from '../fs-cms-page-component-injector';
import { FsEditingAreaComponent } from '../../../../../fs-editing-area/fs-editing-area.component';
import { getFsManagedPageConfigByTemplateId } from '../../../../util/helper';
import { FsSpartacusBridgeConfig, Optional } from 'fs-spartacus-common';
import { first } from 'rxjs/operators';

/**
 * A {@link Pipeline} step that injects the editing area to a content slot if this is empty.
 *
 * @export
 * @class FsEditingAreaInjectorPipelineStep
 * @implements {PipelineStep}
 */
@Injectable({
  providedIn: 'root',
})
export class FsEditingAreaInjectorPipelineStep implements PipelineStep {
  constructor(
    private fsComponentInjector: FsCmsPageComponentInjector,
    private fsSpartacusBridgeConfig: FsSpartacusBridgeConfig,
    private baseSiteService: BaseSiteService
  ) {}

  /**
   * This methode injects the editing area to a content slot if it is empty.
   *
   * @param {CmsStructureModel} occCmsStructureModel The page generated by the SAP Commerce CMS.
   * @param {CmsStructureModel} fsCmsStructureModel The page generated by FirstSpirit.
   * @return {CmsStructureModel} The page that is expanded by an editing area.
   * @memberof FsEditingAreaInjectorPipelineStep
   */
  execute(occCmsStructureModel: CmsStructureModel, fsCmsStructureModel: CmsStructureModel): CmsStructureModel {
    return this.addFsEditingAreasToOccCmsPage(occCmsStructureModel, fsCmsStructureModel);
  }

  private addFsEditingAreasToOccCmsPage(
    occCmsStructureModel: CmsStructureModel,
    fsCmsStructureModel: CmsStructureModel
  ): CmsStructureModel {
    const slots = this.findSlotsThatRequireFsEditingArea(occCmsStructureModel, fsCmsStructureModel);
    return this.fsComponentInjector.addCmsPageComponents(occCmsStructureModel, slots);
  }

  /**
   * This methode returns all slots within the FirstSpirit managed page that are defined in FirstSpirit but empty and not defined or empty in the OCC model.
   *
   * @private
   * @param {CmsStructureModel} occCmsPage The page generated by the OCC CMS.
   * @param {CmsStructureModel} fsCmsPage The page generated by the FirstSpirit CMS.
   * @return {string[]} List of all slots that require a FirstSpirit editing area.
   * @memberof FsEditingAreaInjectorPipelineStep
   */
  private findSlotsThatRequireFsEditingArea(occCmsPage: CmsStructureModel, fsCmsPage: CmsStructureModel): string[] {
    const fsManagedPage = this.findFirstSpiritManagedPage(occCmsPage, fsCmsPage);
    if (fsManagedPage) {
      let slots = fsManagedPage.slots.map((slot) => slot.name);
      if (fsCmsPage) {
        slots = slots.filter((fsManagedSlotName) => this.isSlotDefinedButEmpty(fsCmsPage, fsManagedSlotName));
      }

      if (occCmsPage) {
        slots = slots.filter((fsManagedSlotName) => this.isSlotUndefinedOrEmpty(occCmsPage, fsManagedSlotName));
      }
      return slots;
    }
    return [];
  }

  private findFirstSpiritManagedPage(occCmsPage: CmsStructureModel, fsCmsPage: CmsStructureModel) {
    let baseSite;
    this.baseSiteService
      .getActive()
      .pipe(first())
      .subscribe((activeBaseSite) => (baseSite = activeBaseSite));
    return getFsManagedPageConfigByTemplateId(
      this.fsSpartacusBridgeConfig.bridge[baseSite].firstSpiritManagedPages,
      this.tryGetPageTemplate(occCmsPage) || this.tryGetPageTemplate(fsCmsPage)
    );
  }

  private tryGetPageTemplate(cmsStructureModel: CmsStructureModel): Optional<string> {
    return cmsStructureModel?.page?.properties?.fsPageTemplate || cmsStructureModel?.page?.template || null;
  }

  private isSlotDefinedButEmpty(cmsStructureModel: CmsStructureModel, slotName: string) {
    const slot = getSlotIgnoreCase(cmsStructureModel, slotName);
    return getSlotIgnoreCase(cmsStructureModel, slotName) && this.isContentSlotEmpty(slot);
  }

  private isSlotUndefinedOrEmpty(cmsStructureModel: CmsStructureModel, slotName: string) {
    const slot = getSlotIgnoreCase(cmsStructureModel, slotName);
    return !getSlotIgnoreCase(cmsStructureModel, slotName) || this.isContentSlotEmpty(slot);
  }

  private isContentSlotEmpty(contentSlot: ContentSlotData): boolean {
    return !Array.isArray(contentSlot.components) || contentSlot.components.length === 0;
  }
}

/**
 * A factory function that creates the {@link FsEditingAreaInjectorPipelineStep} from a given FsSpartacusBridgeConfig and BaseSiteService.
 *
 * @export
 * @param {FsSpartacusBridgeConfig} fsSpartacusBridgeConfig The FsSpartacusBridgeConfig from which the step will be created.
 * @param {BaseSiteService} baseSiteService The BaseSiteService to check for the active base site.
 * @return {FsEditingAreaInjectorPipelineStep} The created FsEditingAreaInjectorPipelineStep instance.
 */
export function createFsEditingAreaInjectorPipelineStep(
  fsSpartacusBridgeConfig: FsSpartacusBridgeConfig,
  baseSiteService: BaseSiteService
): FsEditingAreaInjectorPipelineStep {
  const fsComponentInjector: FsCmsPageComponentInjector = new FsCmsPageComponentInjector(FsEditingAreaComponent.TYPE_CODE);
  return new FsEditingAreaInjectorPipelineStep(fsComponentInjector, fsSpartacusBridgeConfig, baseSiteService);
}
